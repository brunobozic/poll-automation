/**
 * Intelligent Failure Analyzer
 * LLM-powered failure analysis engine for automated root cause identification
 * and improvement recommendation generation
 */

const crypto = require('crypto');

class IntelligentFailureAnalyzer {
    constructor(llmService, feedbackDatabase, options = {}) {
        this.llmService = llmService;
        this.db = feedbackDatabase;
        this.options = {
            enableAdvancedPatterns: true,
            enablePredictiveAnalysis: true,
            confidenceThreshold: 0.7,
            maxSimilarFailures: 10,
            enableAutomaticRecommendations: true,
            ...options
        };
        
        this.analysisPromptTemplates = {
            rootCause: this.createRootCausePrompt(),
            patternRecognition: this.createPatternRecognitionPrompt(),
            improvementSuggestions: this.createImprovementPrompt(),
            testGeneration: this.createTestGenerationPrompt()
        };
    }
    
    /**
     * Main entry point: Capture and analyze a failure with full context
     */
    async captureAndAnalyzeFailure(failureContext) {
        console.log('üîç Capturing and analyzing failure...');
        
        try {
            // Step 1: Generate unique scenario hash for deduplication
            const scenarioHash = this.generateScenarioHash(failureContext);
            
            // Step 2: Check if this failure has been seen before
            const existingScenario = await this.findExistingScenario(scenarioHash);
            
            let scenarioId;
            if (existingScenario) {
                // Update occurrence count for existing scenario
                scenarioId = await this.updateExistingScenario(existingScenario.id, failureContext);
                console.log(`üìà Updated existing failure scenario (ID: ${scenarioId})`);
            } else {
                // Create new failure scenario
                scenarioId = await this.createFailureScenario(scenarioHash, failureContext);
                console.log(`üìù Created new failure scenario (ID: ${scenarioId})`);
            }
            
            // Step 3: Perform comprehensive LLM analysis
            const analysisResult = await this.performLLMAnalysis(scenarioId, failureContext);
            
            // Step 4: Generate improvement recommendations
            const recommendations = await this.generateRecommendations(analysisResult, failureContext);
            
            // Step 5: Create automated test cases
            const testCases = await this.generateTestCases(scenarioId, failureContext, recommendations);
            
            // Step 6: Update learning patterns
            await this.updateLearningPatterns(scenarioId, analysisResult);
            
            // Step 7: Update system metrics
            await this.updateSystemMetrics(analysisResult, recommendations);
            
            console.log('‚úÖ Failure analysis complete');
            
            return {
                scenarioId,
                analysisId: analysisResult.id,
                recommendations: recommendations.map(r => r.id),
                testCases: testCases.map(t => t.id),
                insights: {
                    rootCause: analysisResult.root_cause_category,
                    confidence: analysisResult.confidence_score,
                    similarFailures: analysisResult.similar_failures.length,
                    recommendationCount: recommendations.length,
                    testCaseCount: testCases.length
                }
            };
            
        } catch (error) {
            console.error('‚ùå Error in failure analysis:', error);
            throw error;
        }
    }
    
    /**
     * Generate unique hash for failure scenario deduplication
     */
    generateScenarioHash(context) {
        const hashData = {\n            failureType: context.failureType,\n            siteId: context.siteId,\n            errorMessage: context.errorMessage?.substring(0, 100),\n            failedSelector: context.failedSelector,\n            failedAction: context.failedAction,\n            pageUrl: context.pageUrl?.split('?')[0], // Remove query params\n            stepNumber: context.stepNumber\n        };\n        \n        return crypto.createHash('sha256')\n            .update(JSON.stringify(hashData))\n            .digest('hex')\n            .substring(0, 16);\n    }\n    \n    /**\n     * Find existing failure scenario by hash\n     */\n    async findExistingScenario(scenarioHash) {\n        return this.db.get(\n            'SELECT * FROM failure_scenarios WHERE scenario_hash = ?',\n            [scenarioHash]\n        );\n    }\n    \n    /**\n     * Update existing failure scenario with new occurrence\n     */\n    async updateExistingScenario(scenarioId, context) {\n        const stmt = this.db.prepare(`\n            UPDATE failure_scenarios \n            SET occurrence_count = occurrence_count + 1,\n                last_occurrence = CURRENT_TIMESTAMP,\n                page_snapshot = COALESCE(?, page_snapshot),\n                browser_state = COALESCE(?, browser_state),\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = ?\n        `);\n        \n        stmt.run([\n            context.pageSnapshot,\n            JSON.stringify(context.browserState),\n            scenarioId\n        ]);\n        \n        return scenarioId;\n    }\n    \n    /**\n     * Create new failure scenario with complete context\n     */\n    async createFailureScenario(scenarioHash, context) {\n        const stmt = this.db.prepare(`\n            INSERT INTO failure_scenarios (\n                registration_id, scenario_hash, failure_type, severity_level,\n                site_id, email_id, reproduction_recipe, page_snapshot,\n                page_screenshot_path, browser_state, automation_state,\n                llm_interaction_chain, defense_context, environment_data,\n                error_message, error_stack, error_code, failed_selector,\n                failed_action, timeout_duration, page_url, page_title,\n                step_number, total_steps, time_to_failure_ms\n            ) VALUES (\n                ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?\n            )\n        `);\n        \n        const result = stmt.run([\n            context.registrationId,\n            scenarioHash,\n            context.failureType || 'unknown',\n            context.severityLevel || 3,\n            context.siteId,\n            context.emailId,\n            JSON.stringify(context.reproductionRecipe || {}),\n            context.pageSnapshot,\n            context.pageScreenshotPath,\n            JSON.stringify(context.browserState || {}),\n            JSON.stringify(context.automationState || {}),\n            JSON.stringify(context.llmInteractionChain || []),\n            JSON.stringify(context.defenseContext || {}),\n            JSON.stringify(context.environmentData || {}),\n            context.errorMessage,\n            context.errorStack,\n            context.errorCode,\n            context.failedSelector,\n            context.failedAction,\n            context.timeoutDuration,\n            context.pageUrl,\n            context.pageTitle,\n            context.stepNumber,\n            context.totalSteps,\n            context.timeToFailureMs\n        ]);\n        \n        return result.lastInsertRowid;\n    }\n    \n    /**\n     * Perform comprehensive LLM analysis of the failure\n     */\n    async performLLMAnalysis(scenarioId, context) {\n        console.log('üß† Performing LLM root cause analysis...');\n        \n        try {\n            // Get scenario details\n            const scenario = this.db.get('SELECT * FROM failure_scenarios WHERE id = ?', [scenarioId]);\n            \n            // Find similar failures for pattern analysis\n            const similarFailures = await this.findSimilarFailures(scenario);\n            \n            // Construct comprehensive analysis prompt\n            const analysisPrompt = this.buildAnalysisPrompt(scenario, context, similarFailures);\n            \n            // Get LLM analysis\n            const startTime = Date.now();\n            const llmResponse = await this.callLLMForAnalysis(analysisPrompt);\n            const analysisTime = Date.now() - startTime;\n            \n            // Parse and validate LLM response\n            const analysisData = this.parseLLMAnalysisResponse(llmResponse);\n            \n            // Store analysis results\n            const analysisId = await this.storeAnalysisResults(\n                scenarioId, \n                analysisData, \n                analysisPrompt, \n                llmResponse, \n                analysisTime, \n                similarFailures\n            );\n            \n            console.log(`‚úÖ LLM analysis complete (ID: ${analysisId}, Confidence: ${(analysisData.confidence * 100).toFixed(1)}%)`);\n            \n            return {\n                id: analysisId,\n                ...analysisData,\n                similar_failures: similarFailures,\n                analysis_time_ms: analysisTime\n            };\n            \n        } catch (error) {\n            console.error('‚ùå Error in LLM analysis:', error);\n            // Store failed analysis attempt\n            await this.storeFailedAnalysis(scenarioId, error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Build comprehensive analysis prompt for LLM\n     */\n    buildAnalysisPrompt(scenario, context, similarFailures) {\n        return `# üîç Intelligent Failure Analysis Expert\n\nYou are an expert automation failure analyst specializing in web scraping, form automation, and anti-bot countermeasure analysis. Analyze this failure scenario and provide comprehensive root cause analysis.\n\n## üéØ FAILURE SCENARIO\n\n**Failure Type**: ${scenario.failure_type}\n**Site**: ${context.siteName || 'Unknown'}\n**Error**: ${scenario.error_message || 'No error message'}\n**Failed Action**: ${scenario.failed_action || 'Unknown'}\n**Failed Selector**: ${scenario.failed_selector || 'None'}\n**Step**: ${scenario.step_number}/${scenario.total_steps}\n**Occurrence Count**: ${scenario.occurrence_count}\n\n## üìÑ TECHNICAL CONTEXT\n\n**Page URL**: ${scenario.page_url}\n**Page Title**: ${scenario.page_title}\n**Time to Failure**: ${scenario.time_to_failure_ms}ms\n**Timeout Duration**: ${scenario.timeout_duration || 'N/A'}ms\n\n**Error Stack Trace**:\n\\`\\`\\`\n${scenario.error_stack || 'No stack trace available'}\n\\`\\`\\`\n\n**Automation State**:\n\\`\\`\\`json\n${scenario.automation_state || '{}'}\n\\`\\`\\`\n\n**Browser State**:\n\\`\\`\\`json\n${scenario.browser_state || '{}'}\n\\`\\`\\`\n\n**Defense Context**:\n\\`\\`\\`json\n${scenario.defense_context || '{}'}\n\\`\\`\\`\n\n## üîÑ SIMILAR FAILURES\n${similarFailures.length > 0 ? \n    similarFailures.map(f => `- ${f.failure_type}: ${f.error_message} (${f.occurrence_count} times)`).join('\\n') : \n    'No similar failures found'}\n\n## üìã ANALYSIS REQUIREMENTS\n\nProvide your analysis in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"root_cause_category\": \"selector_outdated|timing_issue|anti_bot_detection|site_structure_change|logic_error|network_failure|captcha_challenge|honeypot_triggered|rate_limiting|javascript_error|authentication_required|unknown\",\n  \"root_cause_description\": \"Detailed explanation of the primary cause\",\n  \"confidence_score\": 0.85,\n  \"contributing_factors\": [\"List of secondary factors that contributed to the failure\"],\n  \"failure_frequency_trend\": \"increasing|stable|decreasing\",\n  \"impact_assessment\": {\n    \"severity\": \"low|medium|high|critical\",\n    \"scope\": \"isolated|site_specific|cross_site|systemic\",\n    \"business_impact\": \"Description of impact on automation goals\"\n  },\n  \"pattern_insights\": {\n    \"is_new_pattern\": true,\n    \"pattern_type\": \"Description if this represents a new failure pattern\",\n    \"trend_indicators\": [\"Signs that this might become more common\"]\n  },\n  \"immediate_indicators\": {\n    \"anti_bot_signals\": [\"Specific indicators of anti-bot detection\"],\n    \"site_changes\": [\"Evidence of site structure or behavior changes\"],\n    \"technical_issues\": [\"Technical problems in our automation\"]\n  },\n  \"contextual_analysis\": {\n    \"environmental_factors\": [\"Browser, network, timing factors\"],\n    \"automation_factors\": [\"Issues with our automation logic\"],\n    \"site_factors\": [\"Site-specific behaviors or defenses\"]\n  }\n}\n\\`\\`\\`\n\n## üéØ ANALYSIS FOCUS AREAS\n\n1. **Root Cause Identification**: What is the primary reason this failed?\n2. **Pattern Recognition**: Does this fit known failure patterns?\n3. **Trend Analysis**: Is this failure becoming more common?\n4. **Anti-Bot Assessment**: Are there signs of detection or countermeasures?\n5. **Technical Debt**: Are there systemic issues in our automation?\n6. **Predictive Insights**: What does this tell us about future failures?\n\nProvide detailed, actionable analysis that will help improve our automation system.\n`;\n    }\n    \n    /**\n     * Find similar failures for pattern analysis\n     */\n    async findSimilarFailures(scenario) {\n        const query = `\n            SELECT * FROM failure_scenarios \n            WHERE id != ? \n            AND (\n                failure_type = ? OR\n                site_id = ? OR\n                failed_selector = ? OR\n                failed_action = ? OR\n                error_message LIKE ?\n            )\n            ORDER BY \n                CASE WHEN failure_type = ? THEN 1 ELSE 2 END,\n                occurrence_count DESC,\n                last_occurrence DESC\n            LIMIT ?\n        `;\n        \n        return this.db.all(query, [\n            scenario.id,\n            scenario.failure_type,\n            scenario.site_id,\n            scenario.failed_selector,\n            scenario.failed_action,\n            `%${scenario.error_message?.substring(0, 50) || ''}%`,\n            scenario.failure_type,\n            this.options.maxSimilarFailures\n        ]);\n    }\n    \n    /**\n     * Call LLM service for analysis\n     */\n    async callLLMForAnalysis(prompt) {\n        if (!this.llmService) {\n            // Fallback analysis if no LLM service available\n            return this.generateFallbackAnalysis(prompt);\n        }\n        \n        try {\n            return await this.llmService.generateResponse(prompt, {\n                maxTokens: 2000,\n                temperature: 0.1, // Low temperature for analytical consistency\n                model: 'gpt-4' // Use most capable model for analysis\n            });\n        } catch (error) {\n            console.warn('‚ö†Ô∏è LLM service failed, using fallback analysis');\n            return this.generateFallbackAnalysis(prompt);\n        }\n    }\n    \n    /**\n     * Generate fallback analysis when LLM is unavailable\n     */\n    generateFallbackAnalysis(prompt) {\n        // Extract key information from prompt for basic analysis\n        const failureType = prompt.match(/\\*\\*Failure Type\\*\\*: (.+)/)?.[1] || 'unknown';\n        const errorMessage = prompt.match(/\\*\\*Error\\*\\*: (.+)/)?.[1] || 'No error message';\n        const failedSelector = prompt.match(/\\*\\*Failed Selector\\*\\*: (.+)/)?.[1] || 'None';\n        \n        // Basic rule-based analysis\n        let rootCause = 'unknown';\n        let confidence = 0.5;\n        \n        if (errorMessage.includes('timeout') || errorMessage.includes('Timeout')) {\n            rootCause = 'timing_issue';\n            confidence = 0.8;\n        } else if (errorMessage.includes('selector') || failedSelector !== 'None') {\n            rootCause = 'selector_outdated';\n            confidence = 0.7;\n        } else if (errorMessage.includes('captcha') || errorMessage.includes('CAPTCHA')) {\n            rootCause = 'captcha_challenge';\n            confidence = 0.9;\n        } else if (errorMessage.includes('blocked') || errorMessage.includes('detected')) {\n            rootCause = 'anti_bot_detection';\n            confidence = 0.8;\n        }\n        \n        return JSON.stringify({\n            root_cause_category: rootCause,\n            root_cause_description: `Fallback analysis suggests ${rootCause} based on error patterns: ${errorMessage}`,\n            confidence_score: confidence,\n            contributing_factors: ['LLM analysis unavailable - using rule-based fallback'],\n            failure_frequency_trend: 'stable',\n            impact_assessment: {\n                severity: 'medium',\n                scope: 'isolated',\n                business_impact: 'Automated fallback analysis - manual review recommended'\n            },\n            pattern_insights: {\n                is_new_pattern: false,\n                pattern_type: 'Standard failure requiring LLM analysis',\n                trend_indicators: ['LLM analysis needed for trend identification']\n            },\n            immediate_indicators: {\n                anti_bot_signals: [],\n                site_changes: [],\n                technical_issues: [errorMessage]\n            },\n            contextual_analysis: {\n                environmental_factors: ['Analysis limited without LLM'],\n                automation_factors: ['Manual review required'],\n                site_factors: ['LLM analysis needed']\n            }\n        });\n    }\n    \n    /**\n     * Parse and validate LLM analysis response\n     */\n    parseLLMAnalysisResponse(response) {\n        try {\n            // Extract JSON from response\n            const jsonMatch = response.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n            if (!jsonMatch) {\n                throw new Error('No JSON found in LLM response');\n            }\n            \n            const analysisData = JSON.parse(jsonMatch[1]);\n            \n            // Validate required fields\n            const required = ['root_cause_category', 'root_cause_description', 'confidence_score'];\n            for (const field of required) {\n                if (!analysisData[field]) {\n                    throw new Error(`Missing required field: ${field}`);\n                }\n            }\n            \n            // Validate confidence score\n            if (analysisData.confidence_score < 0 || analysisData.confidence_score > 1) {\n                analysisData.confidence_score = Math.max(0, Math.min(1, analysisData.confidence_score));\n            }\n            \n            return analysisData;\n            \n        } catch (error) {\n            console.warn('‚ö†Ô∏è Failed to parse LLM response, using fallback:', error.message);\n            return {\n                root_cause_category: 'unknown',\n                root_cause_description: 'Failed to parse LLM analysis response',\n                confidence_score: 0.3,\n                contributing_factors: ['LLM response parsing error'],\n                failure_frequency_trend: 'stable',\n                impact_assessment: {\n                    severity: 'medium',\n                    scope: 'isolated',\n                    business_impact: 'Manual review required due to parsing error'\n                }\n            };\n        }\n    }\n    \n    /**\n     * Store analysis results in database\n     */\n    async storeAnalysisResults(scenarioId, analysisData, prompt, response, analysisTime, similarFailures) {\n        const stmt = this.db.prepare(`\n            INSERT INTO failure_analysis (\n                scenario_id, root_cause_category, root_cause_description,\n                confidence_score, similar_failures, pattern_insights,\n                failure_frequency_trend, impact_assessment,\n                llm_analysis_prompt, llm_analysis_response,\n                analysis_tokens_used, analysis_duration_ms\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `);\n        \n        const result = stmt.run([\n            scenarioId,\n            analysisData.root_cause_category,\n            analysisData.root_cause_description,\n            analysisData.confidence_score,\n            JSON.stringify(similarFailures.map(f => f.id)),\n            JSON.stringify(analysisData.pattern_insights || {}),\n            analysisData.failure_frequency_trend || 'stable',\n            JSON.stringify(analysisData.impact_assessment || {}),\n            prompt,\n            response,\n            this.estimateTokens(prompt + response),\n            analysisTime\n        ]);\n        \n        return result.lastInsertRowid;\n    }\n    \n    /**\n     * Store failed analysis attempt\n     */\n    async storeFailedAnalysis(scenarioId, error) {\n        const stmt = this.db.prepare(`\n            INSERT INTO failure_analysis (\n                scenario_id, root_cause_category, root_cause_description,\n                confidence_score, llm_analysis_prompt, llm_analysis_response\n            ) VALUES (?, ?, ?, ?, ?, ?)\n        `);\n        \n        stmt.run([\n            scenarioId,\n            'unknown',\n            `Analysis failed: ${error.message}`,\n            0.0,\n            'Analysis failed due to error',\n            error.stack\n        ]);\n    }\n    \n    /**\n     * Generate improvement recommendations based on analysis\n     */\n    async generateRecommendations(analysisResult, context) {\n        console.log('üí° Generating improvement recommendations...');\n        \n        const recommendations = [];\n        \n        // Generate recommendations based on root cause\n        switch (analysisResult.root_cause_category) {\n            case 'selector_outdated':\n                recommendations.push(await this.createSelectorUpdateRecommendation(analysisResult, context));\n                break;\n            case 'timing_issue':\n                recommendations.push(await this.createTimingRecommendation(analysisResult, context));\n                break;\n            case 'anti_bot_detection':\n                recommendations.push(await this.createAntiDetectionRecommendation(analysisResult, context));\n                break;\n            case 'site_structure_change':\n                recommendations.push(await this.createStructureAdaptationRecommendation(analysisResult, context));\n                break;\n            default:\n                recommendations.push(await this.createGenericRecommendation(analysisResult, context));\n        }\n        \n        // Generate strategic recommendations based on patterns\n        if (analysisResult.similar_failures.length >= 3) {\n            recommendations.push(await this.createPatternBasedRecommendation(analysisResult, context));\n        }\n        \n        return recommendations;\n    }\n    \n    /**\n     * Create selector update recommendation\n     */\n    async createSelectorUpdateRecommendation(analysisResult, context) {\n        const recommendationData = {\n            analysisId: analysisResult.id,\n            scenarioId: context.scenarioId,\n            recommendationType: 'immediate_fix',\n            priorityScore: 8,\n            effortEstimate: 'low',\n            impactPotential: 'high',\n            targetComponent: 'selector_engine',\n            suggestedChanges: `Update selector strategy for ${context.failedSelector}. Implement fallback selectors and dynamic selector discovery.`,\n            claudeCodePrompt: `Fix selector issue: The selector '${context.failedSelector}' is failing. Please update the selector strategy to be more resilient and add fallback options.`,\n            testRequirements: 'Verify selector works on target site and similar sites',\n            validationCriteria: 'Selector successfully identifies target element with >95% reliability'\n        };\n        \n        return await this.storeRecommendation(recommendationData);\n    }\n    \n    /**\n     * Store recommendation in database\n     */\n    async storeRecommendation(data) {\n        const stmt = this.db.prepare(`\n            INSERT INTO improvement_recommendations (\n                analysis_id, scenario_id, recommendation_type, priority_score,\n                effort_estimate, impact_potential, target_component,\n                suggested_changes, claude_code_prompt, test_requirements,\n                validation_criteria\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `);\n        \n        const result = stmt.run([\n            data.analysisId,\n            data.scenarioId,\n            data.recommendationType,\n            data.priorityScore,\n            data.effortEstimate,\n            data.impactPotential,\n            data.targetComponent,\n            data.suggestedChanges,\n            data.claudeCodePrompt,\n            data.testRequirements,\n            data.validationCriteria\n        ]);\n        \n        return {\n            id: result.lastInsertRowid,\n            ...data\n        };\n    }\n    \n    /**\n     * Generate automated test cases for validation\n     */\n    async generateTestCases(scenarioId, context, recommendations) {\n        console.log('üß™ Generating automated test cases...');\n        \n        const testCases = [];\n        \n        // Create reproduction test\n        testCases.push(await this.createReproductionTest(scenarioId, context));\n        \n        // Create validation tests for each recommendation\n        for (const recommendation of recommendations) {\n            testCases.push(await this.createValidationTest(scenarioId, recommendation, context));\n        }\n        \n        return testCases;\n    }\n    \n    /**\n     * Create reproduction test case\n     */\n    async createReproductionTest(scenarioId, context) {\n        const testCode = `\n// Auto-generated reproduction test for scenario ${scenarioId}\nconst { test, expect } = require('@playwright/test');\n\ntest('Reproduce failure scenario ${scenarioId}', async ({ page }) => {\n    // Navigate to failure page\n    await page.goto('${context.pageUrl}');\n    \n    // Reproduce the exact failure conditions\n    ${context.reproductionSteps || '// Add reproduction steps'}\n    \n    // Verify the failure occurs\n    await expect(async () => {\n        ${context.failedAction ? `await page.${context.failedAction}` : '// Add failed action'}\n    }).toThrow();\n});\n`;\n        \n        return await this.storeTestCase({\n            scenarioId,\n            testName: `reproduce_failure_${scenarioId}`,\n            testType: 'reproduction',\n            testCode,\n            expectedBehavior: 'Should reproduce the original failure',\n            expectedOutcome: 'fail'\n        });\n    }\n    \n    /**\n     * Store test case in database\n     */\n    async storeTestCase(data) {\n        const stmt = this.db.prepare(`\n            INSERT INTO reproduction_tests (\n                scenario_id, test_name, test_type, test_code,\n                expected_behavior, expected_outcome\n            ) VALUES (?, ?, ?, ?, ?, ?)\n        `);\n        \n        const result = stmt.run([\n            data.scenarioId,\n            data.testName,\n            data.testType,\n            data.testCode,\n            data.expectedBehavior,\n            data.expectedOutcome\n        ]);\n        \n        return {\n            id: result.lastInsertRowid,\n            ...data\n        };\n    }\n    \n    /**\n     * Update learning patterns based on analysis\n     */\n    async updateLearningPatterns(scenarioId, analysisResult) {\n        // Implementation for pattern learning\n        console.log('üéØ Updating learning patterns...');\n    }\n    \n    /**\n     * Update system metrics\n     */\n    async updateSystemMetrics(analysisResult, recommendations) {\n        const today = new Date().toISOString().split('T')[0];\n        \n        // Update or insert daily metrics\n        const stmt = this.db.prepare(`\n            INSERT INTO feedback_loop_metrics (\n                metric_date, total_failures, analyzed_failures,\n                generated_recommendations, system_learning_score\n            ) VALUES (?, 1, 1, ?, ?)\n            ON CONFLICT(metric_date) DO UPDATE SET\n                total_failures = total_failures + 1,\n                analyzed_failures = analyzed_failures + 1,\n                generated_recommendations = generated_recommendations + ?,\n                updated_at = CURRENT_TIMESTAMP\n        `);\n        \n        stmt.run([\n            today,\n            recommendations.length,\n            analysisResult.confidence_score,\n            recommendations.length\n        ]);\n    }\n    \n    /**\n     * Estimate token count for cost tracking\n     */\n    estimateTokens(text) {\n        // Rough estimation: ~4 characters per token\n        return Math.ceil(text.length / 4);\n    }\n    \n    /**\n     * Get failure analysis dashboard data\n     */\n    async getFailureDashboard(timeframe = '7 days') {\n        return {\n            recentFailures: this.db.all(`\n                SELECT * FROM failure_summary \n                WHERE first_occurrence > datetime('now', '-${timeframe}')\n                ORDER BY last_occurrence DESC\n                LIMIT 20\n            `),\n            topFailureTypes: this.db.all(`\n                SELECT failure_type, COUNT(*) as count\n                FROM failure_scenarios\n                WHERE first_occurrence > datetime('now', '-${timeframe}')\n                GROUP BY failure_type\n                ORDER BY count DESC\n            `),\n            learningProgress: this.db.all(`\n                SELECT * FROM learning_intelligence\n                WHERE date > date('now', '-${timeframe}')\n                ORDER BY date DESC\n            `),\n            pendingRecommendations: this.db.all(`\n                SELECT * FROM recommendation_dashboard\n                WHERE status = 'pending'\n                ORDER BY priority_score DESC\n                LIMIT 10\n            `)\n        };\n    }\n}\n\n// Helper functions for specific recommendation types\nclass RecommendationGenerators {\n    static async createTimingRecommendation(analysisResult, context) {\n        return {\n            recommendationType: 'immediate_fix',\n            priorityScore: 7,\n            effortEstimate: 'low',\n            impactPotential: 'medium',\n            targetComponent: 'timing_engine',\n            suggestedChanges: 'Increase wait times and implement adaptive timing based on site performance',\n            claudeCodePrompt: 'Fix timing issue: Add dynamic wait times and better element availability detection',\n            testRequirements: 'Test with various network conditions and site load times',\n            validationCriteria: 'Timing-related failures reduced by >80%'\n        };\n    }\n    \n    static async createAntiDetectionRecommendation(analysisResult, context) {\n        return {\n            recommendationType: 'strategic_improvement',\n            priorityScore: 9,\n            effortEstimate: 'high',\n            impactPotential: 'critical',\n            targetComponent: 'evasion_engine',\n            suggestedChanges: 'Implement advanced anti-detection measures: behavioral mimicry, fingerprint randomization',\n            claudeCodePrompt: 'Enhance anti-bot evasion: Add human-like behavior patterns and detection avoidance',\n            testRequirements: 'Test against known anti-bot systems and monitor detection rates',\n            validationCriteria: 'Bot detection incidents reduced by >70%'\n        };\n    }\n    \n    static async createStructureAdaptationRecommendation(analysisResult, context) {\n        return {\n            recommendationType: 'architecture_change',\n            priorityScore: 6,\n            effortEstimate: 'medium',\n            impactPotential: 'high',\n            targetComponent: 'adaptation_engine',\n            suggestedChanges: 'Implement dynamic site structure adaptation and change detection',\n            claudeCodePrompt: 'Add site change detection: Monitor for layout changes and adapt automatically',\n            testRequirements: 'Test with sites that have recent structure changes',\n            validationCriteria: 'Automatic adaptation to site changes >90% successful'\n        };\n    }\n}\n\nmodule.exports = IntelligentFailureAnalyzer;