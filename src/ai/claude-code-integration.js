/**
 * Claude Code Integration System
 * Generates structured improvement recommendations and integration prompts for Claude Code
 */

const fs = require('fs').promises;\nconst path = require('path');\n\nclass ClaudeCodeIntegration {\n    constructor(database, options = {}) {\n        this.db = database;\n        this.options = {\n            outputDirectory: './claude-code-tasks',\n            generateGitHubIssues: true,\n            generateImplementationGuides: true,\n            includeTestPlans: true,\n            priorityThreshold: 5,\n            ...options\n        };\n        \n        this.templateEngine = new RecommendationTemplateEngine();\n    }\n    \n    /**\n     * Generate complete Claude Code integration package\n     */\n    async generateIntegrationPackage(timeframe = '7 days') {\n        console.log('🔧 Generating Claude Code integration package...');\n        \n        try {\n            // Get pending recommendations\n            const recommendations = await this.getPendingRecommendations(timeframe);\n            \n            if (recommendations.length === 0) {\n                console.log('ℹ️ No pending recommendations found');\n                return { recommendations: [], files: [] };\n            }\n            \n            // Group recommendations by priority and type\n            const groupedRecommendations = this.groupRecommendations(recommendations);\n            \n            // Generate integration files\n            const generatedFiles = [];\n            \n            // 1. Priority task list\n            generatedFiles.push(await this.generatePriorityTaskList(groupedRecommendations));\n            \n            // 2. Individual implementation guides\n            for (const recommendation of recommendations) {\n                if (recommendation.priority_score >= this.options.priorityThreshold) {\n                    generatedFiles.push(await this.generateImplementationGuide(recommendation));\n                }\n            }\n            \n            // 3. GitHub issues\n            if (this.options.generateGitHubIssues) {\n                generatedFiles.push(await this.generateGitHubIssues(recommendations));\n            }\n            \n            // 4. Test plan summary\n            if (this.options.includeTestPlans) {\n                generatedFiles.push(await this.generateTestPlanSummary(recommendations));\n            }\n            \n            // 5. Strategic roadmap\n            generatedFiles.push(await this.generateStrategicRoadmap(groupedRecommendations));\n            \n            console.log(`✅ Generated ${generatedFiles.length} integration files for ${recommendations.length} recommendations`);\n            \n            return {\n                recommendations,\n                files: generatedFiles,\n                summary: this.generatePackageSummary(recommendations, generatedFiles)\n            };\n            \n        } catch (error) {\n            console.error('❌ Error generating Claude Code integration package:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * Get pending recommendations from database\n     */\n    async getPendingRecommendations(timeframe) {\n        return this.db.all(`\n            SELECT \n                ir.*,\n                fs.failure_type,\n                fs.site_id,\n                fs.error_message,\n                fs.occurrence_count,\n                fa.root_cause_category,\n                fa.confidence_score,\n                ss.site_name\n            FROM improvement_recommendations ir\n            JOIN failure_analysis fa ON ir.analysis_id = fa.id\n            JOIN failure_scenarios fs ON ir.scenario_id = fs.id\n            LEFT JOIN survey_sites ss ON fs.site_id = ss.id\n            WHERE ir.implemented_at IS NULL\n            AND ir.created_at > datetime('now', '-${timeframe}')\n            ORDER BY ir.priority_score DESC, ir.created_at ASC\n        `);\n    }\n    \n    /**\n     * Group recommendations by priority and type\n     */\n    groupRecommendations(recommendations) {\n        const grouped = {\n            critical: recommendations.filter(r => r.priority_score >= 9),\n            high: recommendations.filter(r => r.priority_score >= 7 && r.priority_score < 9),\n            medium: recommendations.filter(r => r.priority_score >= 5 && r.priority_score < 7),\n            low: recommendations.filter(r => r.priority_score < 5),\n            byType: {}\n        };\n        \n        // Group by recommendation type\n        recommendations.forEach(rec => {\n            if (!grouped.byType[rec.recommendation_type]) {\n                grouped.byType[rec.recommendation_type] = [];\n            }\n            grouped.byType[rec.recommendation_type].push(rec);\n        });\n        \n        return grouped;\n    }\n    \n    /**\n     * Generate priority task list for Claude Code\n     */\n    async generatePriorityTaskList(groupedRecommendations) {\n        const content = this.templateEngine.generatePriorityTaskList(groupedRecommendations);\n        const filePath = path.join(this.options.outputDirectory, 'PRIORITY_TASKS.md');\n        \n        await this.ensureDirectoryExists(this.options.outputDirectory);\n        await fs.writeFile(filePath, content);\n        \n        return {\n            type: 'priority_task_list',\n            path: filePath,\n            description: 'Priority-ordered task list for Claude Code implementation'\n        };\n    }\n    \n    /**\n     * Generate individual implementation guide\n     */\n    async generateImplementationGuide(recommendation) {\n        const content = this.templateEngine.generateImplementationGuide(recommendation);\n        const fileName = `implementation_${recommendation.id}_${recommendation.recommendation_type}.md`;\n        const filePath = path.join(this.options.outputDirectory, 'implementations', fileName);\n        \n        await this.ensureDirectoryExists(path.dirname(filePath));\n        await fs.writeFile(filePath, content);\n        \n        return {\n            type: 'implementation_guide',\n            path: filePath,\n            recommendationId: recommendation.id,\n            description: `Implementation guide for ${recommendation.recommendation_type}`\n        };\n    }\n    \n    /**\n     * Generate GitHub issues\n     */\n    async generateGitHubIssues(recommendations) {\n        const issues = recommendations.map(rec => \n            this.templateEngine.generateGitHubIssue(rec)\n        );\n        \n        const content = {\n            issues,\n            summary: {\n                total: issues.length,\n                byLabel: this.categorizeIssues(issues),\n                instructions: this.generateGitHubInstructions()\n            }\n        };\n        \n        const filePath = path.join(this.options.outputDirectory, 'github_issues.json');\n        await fs.writeFile(filePath, JSON.stringify(content, null, 2));\n        \n        // Also generate markdown version\n        const markdownContent = this.templateEngine.generateGitHubIssuesMarkdown(issues);\n        const markdownPath = path.join(this.options.outputDirectory, 'GITHUB_ISSUES.md');\n        await fs.writeFile(markdownPath, markdownContent);\n        \n        return {\n            type: 'github_issues',\n            path: filePath,\n            markdownPath,\n            description: 'GitHub issues ready for import',\n            issueCount: issues.length\n        };\n    }\n    \n    /**\n     * Generate test plan summary\n     */\n    async generateTestPlanSummary(recommendations) {\n        // Get associated test cases\n        const testCases = await this.getTestCasesForRecommendations(\n            recommendations.map(r => r.id)\n        );\n        \n        const content = this.templateEngine.generateTestPlanSummary(recommendations, testCases);\n        const filePath = path.join(this.options.outputDirectory, 'TEST_PLAN.md');\n        \n        await fs.writeFile(filePath, content);\n        \n        return {\n            type: 'test_plan',\n            path: filePath,\n            description: 'Comprehensive test plan for all recommendations',\n            testCaseCount: testCases.length\n        };\n    }\n    \n    /**\n     * Generate strategic roadmap\n     */\n    async generateStrategicRoadmap(groupedRecommendations) {\n        const content = this.templateEngine.generateStrategicRoadmap(groupedRecommendations);\n        const filePath = path.join(this.options.outputDirectory, 'STRATEGIC_ROADMAP.md');\n        \n        await fs.writeFile(filePath, content);\n        \n        return {\n            type: 'strategic_roadmap',\n            path: filePath,\n            description: 'Long-term strategic improvement roadmap'\n        };\n    }\n    \n    /**\n     * Get test cases for recommendations\n     */\n    async getTestCasesForRecommendations(recommendationIds) {\n        const placeholders = recommendationIds.map(() => '?').join(',');\n        return this.db.all(`\n            SELECT rt.*, fs.failure_type, fs.site_id\n            FROM reproduction_tests rt\n            LEFT JOIN failure_scenarios fs ON rt.scenario_id = fs.id\n            WHERE rt.recommendation_id IN (${placeholders})\n            ORDER BY rt.test_type, rt.created_at\n        `, recommendationIds);\n    }\n    \n    /**\n     * Categorize issues for GitHub\n     */\n    categorizeIssues(issues) {\n        const categories = {};\n        issues.forEach(issue => {\n            issue.labels.forEach(label => {\n                categories[label] = (categories[label] || 0) + 1;\n            });\n        });\n        return categories;\n    }\n    \n    /**\n     * Generate GitHub instructions\n     */\n    generateGitHubInstructions() {\n        return {\n            import: 'Use GitHub CLI: gh issue create --title \"TITLE\" --body \"BODY\" --label \"LABELS\"',\n            automation: 'Consider using GitHub Actions to auto-create issues from this JSON',\n            templates: 'Customize issue templates based on recommendation types'\n        };\n    }\n    \n    /**\n     * Generate package summary\n     */\n    generatePackageSummary(recommendations, files) {\n        return {\n            generatedAt: new Date().toISOString(),\n            recommendationCount: recommendations.length,\n            fileCount: files.length,\n            priorityBreakdown: {\n                critical: recommendations.filter(r => r.priority_score >= 9).length,\n                high: recommendations.filter(r => r.priority_score >= 7 && r.priority_score < 9).length,\n                medium: recommendations.filter(r => r.priority_score >= 5 && r.priority_score < 7).length,\n                low: recommendations.filter(r => r.priority_score < 5).length\n            },\n            typeBreakdown: this.getTypeBreakdown(recommendations),\n            estimatedEffort: this.calculateEstimatedEffort(recommendations),\n            expectedImpact: this.calculateExpectedImpact(recommendations)\n        };\n    }\n    \n    /**\n     * Get breakdown by recommendation type\n     */\n    getTypeBreakdown(recommendations) {\n        const breakdown = {};\n        recommendations.forEach(rec => {\n            breakdown[rec.recommendation_type] = (breakdown[rec.recommendation_type] || 0) + 1;\n        });\n        return breakdown;\n    }\n    \n    /**\n     * Calculate estimated effort\n     */\n    calculateEstimatedEffort(recommendations) {\n        const effortMap = { low: 1, medium: 3, high: 8, epic: 21 };\n        const totalPoints = recommendations.reduce((sum, rec) => {\n            return sum + (effortMap[rec.effort_estimate] || 3);\n        }, 0);\n        \n        return {\n            totalStoryPoints: totalPoints,\n            estimatedDays: Math.ceil(totalPoints / 3),\n            breakdown: {\n                low: recommendations.filter(r => r.effort_estimate === 'low').length,\n                medium: recommendations.filter(r => r.effort_estimate === 'medium').length,\n                high: recommendations.filter(r => r.effort_estimate === 'high').length,\n                epic: recommendations.filter(r => r.effort_estimate === 'epic').length\n            }\n        };\n    }\n    \n    /**\n     * Calculate expected impact\n     */\n    calculateExpectedImpact(recommendations) {\n        const impactMap = { low: 1, medium: 3, high: 8, critical: 13 };\n        const totalImpact = recommendations.reduce((sum, rec) => {\n            return sum + (impactMap[rec.impact_potential] || 3);\n        }, 0);\n        \n        return {\n            totalImpactScore: totalImpact,\n            averageImpact: totalImpact / recommendations.length,\n            breakdown: {\n                low: recommendations.filter(r => r.impact_potential === 'low').length,\n                medium: recommendations.filter(r => r.impact_potential === 'medium').length,\n                high: recommendations.filter(r => r.impact_potential === 'high').length,\n                critical: recommendations.filter(r => r.impact_potential === 'critical').length\n            }\n        };\n    }\n    \n    /**\n     * Ensure directory exists\n     */\n    async ensureDirectoryExists(dirPath) {\n        try {\n            await fs.access(dirPath);\n        } catch {\n            await fs.mkdir(dirPath, { recursive: true });\n        }\n    }\n    \n    /**\n     * Create Claude Code prompt for specific recommendation\n     */\n    generateClaudeCodePrompt(recommendation) {\n        return this.templateEngine.generateClaudeCodePrompt(recommendation);\n    }\n    \n    /**\n     * Mark recommendation as implemented\n     */\n    async markAsImplemented(recommendationId, implementationResult) {\n        const stmt = this.db.prepare(`\n            UPDATE improvement_recommendations \n            SET implemented_at = CURRENT_TIMESTAMP,\n                implementation_result = ?,\n                effectiveness_score = ?\n            WHERE id = ?\n        `);\n        \n        stmt.run([\n            implementationResult.description,\n            implementationResult.effectivenessScore || null,\n            recommendationId\n        ]);\n        \n        // Log implementation tracking\n        await this.logImplementation(recommendationId, implementationResult);\n    }\n    \n    /**\n     * Log implementation in tracking table\n     */\n    async logImplementation(recommendationId, result) {\n        const stmt = this.db.prepare(`\n            INSERT INTO fix_implementations (\n                recommendation_id, implementation_method, implementer,\n                implementation_start, implementation_end,\n                files_modified, validation_score, status, success\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `);\n        \n        stmt.run([\n            recommendationId,\n            result.method || 'claude_code',\n            result.implementer || 'claude_code',\n            result.startTime || new Date().toISOString(),\n            result.endTime || new Date().toISOString(),\n            JSON.stringify(result.filesModified || []),\n            result.effectivenessScore || null,\n            result.success ? 'completed' : 'failed',\n            result.success || false\n        ]);\n    }\n}\n\n/**\n * Template Engine for generating various output formats\n */\nclass RecommendationTemplateEngine {\n    \n    /**\n     * Generate priority task list\n     */\n    generatePriorityTaskList(groupedRecommendations) {\n        return `# 🎯 Priority Task List for Claude Code Implementation\n\nGenerated: ${new Date().toISOString()}\n\n## 🚨 Critical Priority (Score 9-10)\n${this.formatRecommendationList(groupedRecommendations.critical)}\n\n## 🔥 High Priority (Score 7-8)\n${this.formatRecommendationList(groupedRecommendations.high)}\n\n## ⚡ Medium Priority (Score 5-6)\n${this.formatRecommendationList(groupedRecommendations.medium)}\n\n## 📋 Low Priority (Score 1-4)\n${this.formatRecommendationList(groupedRecommendations.low)}\n\n## 📊 Summary by Type\n${Object.entries(groupedRecommendations.byType).map(([type, recs]) => \n    `### ${type.replace(/_/g, ' ').toUpperCase()}\n${this.formatRecommendationList(recs)}`\n).join('\\n\\n')}\n\n## 🔧 Quick Implementation Guide\n\n1. **Start with Critical items** - These address systemic failures\n2. **Group similar recommendations** - Implement related fixes together\n3. **Run tests after each fix** - Verify no regressions introduced\n4. **Monitor effectiveness** - Track success rate improvements\n\n## 💡 Claude Code Commands\n\n\\`\\`\\`bash\n# Example commands for implementation\nnode implement-recommendation.js --id=RECOMMENDATION_ID\nnode run-validation-tests.js --recommendation=RECOMMENDATION_ID\nnode measure-effectiveness.js --before --after\n\\`\\`\\`\n`;\n    }\n    \n    /**\n     * Generate implementation guide for specific recommendation\n     */\n    generateImplementationGuide(recommendation) {\n        return `# 🔧 Implementation Guide: ${recommendation.recommendation_type}\n\n**Recommendation ID:** ${recommendation.id}  \n**Priority Score:** ${recommendation.priority_score}/10  \n**Effort Estimate:** ${recommendation.effort_estimate}  \n**Impact Potential:** ${recommendation.impact_potential}  \n\n## 🎯 Objective\n\n${recommendation.suggested_changes}\n\n## 🔍 Root Cause Analysis\n\n**Failure Type:** ${recommendation.failure_type}  \n**Root Cause:** ${recommendation.root_cause_category}  \n**Confidence:** ${(recommendation.confidence_score * 100).toFixed(1)}%  \n**Site Affected:** ${recommendation.site_name || 'Multiple sites'}  \n**Error:** ${recommendation.error_message || 'N/A'}  \n\n## 🛠️ Implementation Details\n\n**Target Component:** ${recommendation.target_component}\n\n### Suggested Changes\n${recommendation.suggested_changes}\n\n### Target Files\n${recommendation.target_files ? JSON.parse(recommendation.target_files).map(f => `- ${f}`).join('\\n') : 'To be determined during implementation'}\n\n### Configuration Changes\n${recommendation.configuration_changes || 'None specified'}\n\n## 🧪 Testing Requirements\n\n${recommendation.test_requirements}\n\n### Validation Criteria\n${recommendation.validation_criteria}\n\n### Test Scenarios\n${recommendation.test_scenarios ? JSON.parse(recommendation.test_scenarios).map(t => `- ${t}`).join('\\n') : 'Standard validation tests'}\n\n## ⚠️ Regression Risks\n\n${recommendation.regression_risks || 'Standard regression testing recommended'}\n\n## 🚀 Claude Code Prompt\n\n\\`\\`\\`\n${recommendation.claude_code_prompt}\n\\`\\`\\`\n\n## ✅ Implementation Checklist\n\n${recommendation.implementation_checklist ? \n    JSON.parse(recommendation.implementation_checklist).map(item => `- [ ] ${item}`).join('\\n') : \n    `- [ ] Review current implementation\n- [ ] Implement suggested changes\n- [ ] Run validation tests\n- [ ] Verify no regressions\n- [ ] Monitor effectiveness`}\n\n## 📊 Success Metrics\n\n- **Expected Improvement:** ${recommendation.impact_potential} impact\n- **Validation:** ${recommendation.validation_criteria}\n- **Effectiveness Measurement:** Monitor failure rate reduction\n\n## 🔄 Rollback Plan\n\n${recommendation.rollback_instructions || 'Standard rollback procedures apply'}\n`;\n    }\n    \n    /**\n     * Generate GitHub issue\n     */\n    generateGitHubIssue(recommendation) {\n        const labels = this.generateGitHubLabels(recommendation);\n        \n        return {\n            title: `[${recommendation.recommendation_type.toUpperCase()}] ${recommendation.root_cause_category.replace(/_/g, ' ')}`,\n            body: `## 🎯 Problem Description\n\n${recommendation.suggested_changes}\n\n## 🔍 Root Cause\n\n- **Type:** ${recommendation.root_cause_category}\n- **Confidence:** ${(recommendation.confidence_score * 100).toFixed(1)}%\n- **Site:** ${recommendation.site_name || 'Multiple'}\n- **Failure Count:** ${recommendation.occurrence_count || 1}\n\n## 🛠️ Proposed Solution\n\n${recommendation.suggested_changes}\n\n## 🧪 Acceptance Criteria\n\n${recommendation.validation_criteria}\n\n## 📋 Implementation Notes\n\n- **Effort:** ${recommendation.effort_estimate}\n- **Impact:** ${recommendation.impact_potential}\n- **Component:** ${recommendation.target_component}\n\n---\n*Auto-generated from failure analysis recommendation #${recommendation.id}*`,\n            labels,\n            assignees: [],\n            milestone: null,\n            projects: []\n        };\n    }\n    \n    /**\n     * Generate GitHub labels based on recommendation\n     */\n    generateGitHubLabels(recommendation) {\n        const labels = ['automation', 'feedback-loop'];\n        \n        // Priority labels\n        if (recommendation.priority_score >= 9) labels.push('priority:critical');\n        else if (recommendation.priority_score >= 7) labels.push('priority:high');\n        else if (recommendation.priority_score >= 5) labels.push('priority:medium');\n        else labels.push('priority:low');\n        \n        // Type labels\n        labels.push(`type:${recommendation.recommendation_type}`);\n        \n        // Effort labels\n        labels.push(`effort:${recommendation.effort_estimate}`);\n        \n        // Impact labels\n        labels.push(`impact:${recommendation.impact_potential}`);\n        \n        // Component labels\n        if (recommendation.target_component) {\n            labels.push(`component:${recommendation.target_component}`);\n        }\n        \n        return labels;\n    }\n    \n    /**\n     * Generate GitHub issues markdown\n     */\n    generateGitHubIssuesMarkdown(issues) {\n        return `# 📋 GitHub Issues for Automation Improvements\n\nGenerated: ${new Date().toISOString()}\n\n## 🎯 Summary\n\n- **Total Issues:** ${issues.length}\n- **Critical:** ${issues.filter(i => i.labels.includes('priority:critical')).length}\n- **High Priority:** ${issues.filter(i => i.labels.includes('priority:high')).length}\n- **Medium Priority:** ${issues.filter(i => i.labels.includes('priority:medium')).length}\n- **Low Priority:** ${issues.filter(i => i.labels.includes('priority:low')).length}\n\n## 📝 Issues\n\n${issues.map((issue, index) => `\n### ${index + 1}. ${issue.title}\n\n**Labels:** ${issue.labels.join(', ')}\n\n${issue.body}\n\n---\n`).join('')}\n\n## 🚀 Import Instructions\n\n### Using GitHub CLI\n\\`\\`\\`bash\n${issues.map(issue => \n    `gh issue create --title \"${issue.title}\" --body \"${issue.body.replace(/\"/g, '\\\\\\\\"')}\" --label \"${issue.labels.join(',')}\"`\n).join('\\n')}\n\\`\\`\\`\n\n### Using GitHub API\nSee \\`github_issues.json\\` for programmatic import.\n`;\n    }\n    \n    /**\n     * Generate test plan summary\n     */\n    generateTestPlanSummary(recommendations, testCases) {\n        return `# 🧪 Comprehensive Test Plan\n\nGenerated: ${new Date().toISOString()}\n\n## 📊 Overview\n\n- **Recommendations:** ${recommendations.length}\n- **Test Cases:** ${testCases.length}\n- **Test Types:** ${[...new Set(testCases.map(t => t.test_type))].join(', ')}\n\n## 🎯 Test Strategy\n\n### 1. Reproduction Tests\nVerify that original failures can be reliably reproduced before fixes.\n\n### 2. Validation Tests\nConfirm that each fix resolves the intended issue.\n\n### 3. Regression Tests\nEnsure no new failures are introduced by fixes.\n\n### 4. Integration Tests\nValidate end-to-end workflows after all changes.\n\n## 📋 Test Cases by Recommendation\n\n${recommendations.map(rec => {\n    const relatedTests = testCases.filter(t => t.recommendation_id === rec.id);\n    return `\n### Recommendation ${rec.id}: ${rec.recommendation_type}\n\n**Priority:** ${rec.priority_score}/10  \n**Tests:** ${relatedTests.length}\n\n${relatedTests.map(test => `\n#### ${test.test_name}\n- **Type:** ${test.test_type}\n- **Expected:** ${test.expected_outcome}\n- **Description:** ${test.test_description || 'N/A'}\n`).join('')}\n`;\n}).join('')}\n\n## 🔄 Test Execution Plan\n\n### Phase 1: Pre-Implementation\n1. Run all reproduction tests to establish baseline\n2. Verify all reproduction tests fail as expected\n\n### Phase 2: During Implementation\n1. Run relevant validation tests for each fix\n2. Run regression tests after each change\n\n### Phase 3: Post-Implementation\n1. Run complete test suite\n2. Monitor for new failure patterns\n3. Update test cases based on findings\n\n## 📈 Success Metrics\n\n- **Reproduction Tests:** Should initially fail, then pass after fixes\n- **Validation Tests:** Should pass after implementation\n- **Regression Tests:** Should maintain passing status\n- **Overall Success Rate:** Target >95% automation success rate\n\n## 🛠️ Test Environment Requirements\n\n- **Browser:** Chromium/Playwright\n- **Node.js:** Latest LTS version\n- **Dependencies:** See package.json\n- **Network:** Stable internet connection\n- **Monitoring:** Real-time failure detection\n`;\n    }\n    \n    /**\n     * Generate strategic roadmap\n     */\n    generateStrategicRoadmap(groupedRecommendations) {\n        return `# 🗺️ Strategic Improvement Roadmap\n\nGenerated: ${new Date().toISOString()}\n\n## 🎯 Executive Summary\n\nThis roadmap outlines a systematic approach to improving automation reliability through intelligent failure analysis and targeted fixes.\n\n### Key Metrics\n- **Total Recommendations:** ${Object.values(groupedRecommendations.byType).flat().length}\n- **Critical Issues:** ${groupedRecommendations.critical.length}\n- **Estimated Timeline:** ${this.estimateTimeline(groupedRecommendations)} weeks\n\n## 🚀 Implementation Phases\n\n### Phase 1: Critical Fixes (Week 1-2)\n**Focus:** Address systemic failures and high-impact issues\n\n${this.formatRoadmapPhase(groupedRecommendations.critical, 'critical')}\n\n### Phase 2: High Priority (Week 3-4)\n**Focus:** Improve reliability and reduce failure rates\n\n${this.formatRoadmapPhase(groupedRecommendations.high, 'high')}\n\n### Phase 3: Medium Priority (Week 5-6)\n**Focus:** Enhance robustness and edge case handling\n\n${this.formatRoadmapPhase(groupedRecommendations.medium, 'medium')}\n\n### Phase 4: Strategic Improvements (Week 7+)\n**Focus:** Long-term architecture and optimization\n\n${this.formatRoadmapPhase(groupedRecommendations.low, 'strategic')}\n\n## 📊 Implementation Strategy by Type\n\n${Object.entries(groupedRecommendations.byType).map(([type, recs]) => `\n### ${type.replace(/_/g, ' ').toUpperCase()}\n- **Count:** ${recs.length}\n- **Priority Range:** ${Math.min(...recs.map(r => r.priority_score))}-${Math.max(...recs.map(r => r.priority_score))}\n- **Strategy:** ${this.getTypeStrategy(type)}\n`).join('')}\n\n## 🎯 Success Criteria\n\n### Short-term (1 month)\n- [ ] All critical issues resolved\n- [ ] 50% reduction in high-frequency failures\n- [ ] Automated test coverage >90%\n\n### Medium-term (3 months)\n- [ ] 80% reduction in overall failure rate\n- [ ] Proactive failure detection implemented\n- [ ] Self-healing capabilities for common issues\n\n### Long-term (6 months)\n- [ ] Predictive failure prevention\n- [ ] Zero-intervention failure handling\n- [ ] Continuous learning and adaptation\n\n## 🔄 Monitoring & Feedback\n\n### Key Performance Indicators\n- **Failure Rate:** Target <5% overall failure rate\n- **MTTR:** Mean time to resolution <2 hours\n- **Learning Velocity:** Pattern recognition within 3 similar failures\n- **Self-Healing:** 70% of failures handled automatically\n\n### Continuous Improvement\n- Weekly failure analysis reviews\n- Monthly roadmap updates\n- Quarterly strategic assessment\n- Annual architecture review\n\n## 🛠️ Resource Requirements\n\n### Development Time\n- **Critical Phase:** 2 weeks focused development\n- **Implementation Phase:** 4-6 weeks steady progress\n- **Monitoring Phase:** Ongoing maintenance\n\n### Technical Requirements\n- Claude Code or equivalent AI development assistant\n- Comprehensive test infrastructure\n- Real-time monitoring and alerting\n- Failure analytics dashboard\n\n## 🎉 Expected Outcomes\n\n### Immediate Benefits\n- Reduced manual intervention\n- Faster failure resolution\n- Improved system reliability\n\n### Long-term Value\n- Self-improving automation system\n- Predictive failure prevention\n- Competitive advantage through reliability\n`;\n    }\n    \n    /**\n     * Generate Claude Code prompt\n     */\n    generateClaudeCodePrompt(recommendation) {\n        return `# 🤖 Claude Code Implementation Request\n\n## 🎯 Task: ${recommendation.recommendation_type.replace(/_/g, ' ').toUpperCase()}\n\n### Background\n${recommendation.suggested_changes}\n\n### Root Cause Analysis\n- **Failure Type:** ${recommendation.failure_type}\n- **Root Cause:** ${recommendation.root_cause_category}\n- **Confidence:** ${(recommendation.confidence_score * 100).toFixed(1)}%\n- **Site:** ${recommendation.site_name || 'Multiple sites'}\n- **Occurrences:** ${recommendation.occurrence_count || 1}\n\n### Implementation Requirements\n1. **Target Component:** ${recommendation.target_component}\n2. **Effort Level:** ${recommendation.effort_estimate}\n3. **Expected Impact:** ${recommendation.impact_potential}\n\n### Specific Tasks\n${recommendation.suggested_changes}\n\n### Validation Requirements\n${recommendation.validation_criteria}\n\n### Testing\n${recommendation.test_requirements}\n\n### Success Criteria\n- Fix resolves the identified failure pattern\n- No regressions introduced\n- Validation tests pass\n- Performance impact minimal\n\nPlease implement this fix and create appropriate tests for validation.`;\n    }\n    \n    /**\n     * Format recommendation list\n     */\n    formatRecommendationList(recommendations) {\n        if (recommendations.length === 0) {\n            return '*No recommendations in this category*';\n        }\n        \n        return recommendations.map(rec => \n            `- **[${rec.priority_score}/10]** ${rec.recommendation_type.replace(/_/g, ' ')} - ${rec.root_cause_category} \\n  *${rec.suggested_changes.substring(0, 100)}...*\\n  **Effort:** ${rec.effort_estimate} | **Impact:** ${rec.impact_potential} | **ID:** ${rec.id}`\n        ).join('\\n\\n');\n    }\n    \n    /**\n     * Format roadmap phase\n     */\n    formatRoadmapPhase(recommendations, phase) {\n        if (recommendations.length === 0) {\n            return `*No ${phase} recommendations*`;\n        }\n        \n        return recommendations.map(rec => \n            `- ${rec.recommendation_type.replace(/_/g, ' ')} (${rec.effort_estimate} effort, ${rec.impact_potential} impact)`\n        ).join('\\n');\n    }\n    \n    /**\n     * Estimate timeline\n     */\n    estimateTimeline(groupedRecommendations) {\n        const effortMap = { low: 1, medium: 3, high: 8, epic: 21 };\n        const allRecs = Object.values(groupedRecommendations.byType).flat();\n        const totalEffort = allRecs.reduce((sum, rec) => sum + (effortMap[rec.effort_estimate] || 3), 0);\n        return Math.ceil(totalEffort / 10); // Assuming 10 story points per week\n    }\n    \n    /**\n     * Get strategy for recommendation type\n     */\n    getTypeStrategy(type) {\n        const strategies = {\n            'immediate_fix': 'Quick targeted fixes for specific failures',\n            'strategic_improvement': 'Systematic enhancements for long-term reliability',\n            'architecture_change': 'Structural improvements for scalability',\n            'configuration_update': 'Settings optimization for better performance'\n        };\n        \n        return strategies[type] || 'Custom implementation strategy';\n    }\n}\n\nmodule.exports = ClaudeCodeIntegration;